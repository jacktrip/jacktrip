\documentclass{ieeetj}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx,color}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{hidelinks=true}
\usepackage{algorithm,algorithmic}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\AtBeginDocument{\definecolor{tmlcncolor}{cmyk}{0.93,0.59,0.15,0.02}\definecolor{NavyBlue}{RGB}{0,86,125}}




\def\OJlogo{\vspace{-4pt}$<$Society logo(s) and publication title will appear here.$>$}
\def\seclogo{\vspace{10pt}$<$Society logo(s) and publication title will appear here.$>$}

\def\authorrefmark#1{\ensuremath{^{\textbf{#1}}}}

\begin{document}
\receiveddate{XX Month, XXXX}
\reviseddate{XX Month, XXXX}
\accepteddate{XX Month, XXXX}
\publisheddate{XX Month, XXXX}
\currentdate{XX Month, XXXX}
\doiinfo{XXXX.2022.1234567}

\markboth{}{Author {et al.}}

\title{Packet Loss Concealment for Server-Mediated Network Audio Systems}

\author{Chris Chafe\authorrefmark{1}, Mike Dickey\authorrefmark{2}}
\affil{Stanford University, Stanford, CA 94305 USA}
\affil{JackTrip Labs, Palo Alto, CA 94304 USA}
\corresp{Corresponding author: Chris Chafe (email: cc@ ccrma.stanford.edu).}
\authornote{}


\begin{abstract}
This paper presents a novel packet loss concealment system called "Regulator" designed for interactive network audio applications, particularly server-mediated "jam rooms" in the cloud where large ensembles of musicians perform together synchronously. The system addresses the critical challenge of maintaining continuous high-quality audio output while minimizing latency penalties in unreliable network environments. The Regulator architecture combines four core components: a central Regulator class orchestrating packet loss concealment operations, a BurgAlgorithm class implementing maximum entropy autoregressive prediction for missing audio samples, individual Channel classes providing per-channel independent modeling for multi-channel streams, and an optional RegulatorWorker class offering asynchronous processing through lock-free threading. The system features sophisticated adaptive mechanisms including tolerance management that automatically adjusts buffer headroom based on observed network jitter patterns, intelligent packet selection logic evaluating multiple candidate packets for optimal playback timing, and cross-fading mechanisms ensuring smooth transitions between predicted and real audio to minimize audible artifacts. Unlike traditional approaches that add significant delay or produce glitchy substitutes, Regulator passes received streams through with minimal added delay while providing high-quality packet loss concealment through Burg algorithm-based prediction, supporting various audio formats including different bit depths, frame sizes, and multi-channel configurations for deployment across heterogeneous network audio scenarios.

\end{abstract}

\begin{IEEEkeywords}
audio signal processing, buffer management, cloud computing, digital signal processing, network audio, packet loss concealment, predictive algorithms, quality of service, telecommunications computing

\end{IEEEkeywords}

%\IEEEspecialpapernotice{(Invited Paper)}

\maketitle

\section{Introduction}

\IEEEPARstart{T}{he} proliferation of cloud-based collaborative audio platforms has created unprecedented opportunities for distributed musical performance and audio collaboration. Modern network infrastructure enables musicians separated by continents to perform together in real-time, fostering new forms of artistic expression and democratizing access to ensemble performance. However, these applications face fundamental challenges imposed by the inherent unreliability of packet-switched networks, where variable latency, jitter, and packet loss can severely compromise audio quality and synchronization.

\subsection{Motivation and Problem Statement}

Traditional packet loss concealment techniques, while adequate for speech communication and non-interactive streaming applications, prove insufficient for the stringent requirements of networked music performance. The perceptual demands of musical audio differ significantly from speech, requiring preservation of harmonic content, transient characteristics, and stereo imaging that simple interpolation or repetition methods cannot maintain. Furthermore, interactive applications impose strict latency constraints that preclude the large buffering strategies commonly employed in streaming media systems.

The emergence of server-mediated architectures for network audio presents both opportunities and challenges. While centralized mixing and distribution can reduce the complexity of many-to-many communication, it also introduces additional points of failure and requires sophisticated packet loss concealment at the server level. Current approaches typically resort to muting or simple substitution when packets are lost, creating audible artifacts that disrupt the musical experience and compromise ensemble synchronization.

\subsection{Related Work}

Early packet loss concealment research focused primarily on speech applications, where simple techniques such as silence insertion, last packet repetition, and linear interpolation provided acceptable quality for intelligibility-focused applications \cite{Sanneck2000,Jiang2002}. These methods, while computationally efficient, produce readily audible artifacts when applied to musical content due to their inability to preserve spectral characteristics and harmonic structure.

More sophisticated approaches have employed autoregressive modeling and spectral prediction techniques to reconstruct missing audio segments. The Linear Predictive Coding (LPC) framework has been extensively studied for speech enhancement applications \cite{Vaseghi2008}, while maximum entropy methods such as the Burg algorithm have shown promise for higher-quality reconstruction of broadband audio signals \cite{Markel1976}. However, these techniques have typically been applied in offline or high-latency scenarios where computational constraints are less restrictive.

Recent advances in machine learning have introduced neural network-based approaches to packet loss concealment \cite{Liu2019,Kemp2018}, demonstrating improved perceptual quality for certain classes of audio content. However, these methods often require substantial computational resources and training data, making them less suitable for real-time applications with diverse audio content and varying network conditions.

\subsection{Contributions}

This paper presents the Regulator system, a novel packet loss concealment architecture specifically designed for real-time networked audio applications. The primary contributions include:

\begin{itemize}
\item A low-latency packet loss concealment framework that combines adaptive buffering with Burg algorithm-based prediction to maintain audio continuity without introducing significant delay
\item A multi-threaded architecture that separates time-critical audio processing from computationally intensive prediction operations using lock-free data structures
\item Adaptive tolerance management mechanisms that automatically adjust buffer parameters based on observed network conditions and performance metrics
\item Per-channel autoregressive modeling that enables independent processing of multi-channel audio streams while maintaining computational efficiency
\item Comprehensive cross-fading and transition management to minimize audible artifacts during switches between predicted and real audio content
\end{itemize}

\subsection{Organization}

The remainder of this paper is organized as follows. Section II provides detailed descriptions of the system architecture and core algorithms. Section III presents the experimental methodology and evaluation framework. Section IV discusses the results and performance characteristics under various network conditions. Section V analyzes the implications and limitations of the approach, and Section VI concludes with directions for future research.

\section{System Architecture and Implementation}

\IEEEPARstart{T}{he} Regulator system was developed as an advanced buffering strategy for JackTrip, a widely-used network music performance application that enables real-time audio collaboration over the Internet. JackTrip provides user-selectable buffering strategies, allowing the Regulator to be compared against traditional approaches such as fixed-size ring buffers and basic jitter buffers. The system addresses the fundamental challenge of maintaining continuous audio playback in unreliable network environments through a multi-layered architecture that separates timing-critical operations from computationally intensive prediction algorithms.

The design philosophy centers on minimizing latency while providing high-quality packet loss concealment through adaptive buffering and sophisticated audio prediction techniques. Unlike conventional approaches that add significant delay to accommodate network irregularities, the Regulator passes received streams through the system as close to real-time as possible while invoking packet loss concealment only when necessary to address signal discontinuities.

\subsection{Core System Components}

The system architecture comprises four interconnected components that work in concert to provide seamless audio delivery, as shown in Fig.~\ref{fig:system_overview}. The Regulator class serves as the central orchestrator, inheriting from JackTrip's existing RingBuffer interface to enable seamless integration while providing enhanced packet loss concealment capabilities. The BurgAlgorithm class provides maximum entropy prediction capabilities, individual Channel classes manage per-channel state and processing, and the optional RegulatorWorker class enables asynchronous processing through lock-free threading mechanisms.

\begin{figure}[!t]
\centering
\includegraphics[width=\columnwidth]{system.png}
\caption{Regulator system architecture showing the four core components and data flow from incoming network packets through processing to audio output within the JackTrip framework.}
\label{fig:system_overview}
\end{figure}


The Regulator class maintains separate frame-per-packet (FPP) configurations for local audio interfaces (\texttt{mLocalFPP}) and peer network packets (\texttt{mPeerFPP}), enabling operation across heterogeneous network configurations with different buffer sizes and sample rates. The system's initialization sequence is triggered upon receipt of the first peer packet, automatically determining the peer's FPP configuration and establishing appropriate prediction window sizes based on the available packet history.

The BurgAlgorithm class implements the maximum entropy method for autoregressive coefficient estimation, forming the core of the packet loss concealment capability. The algorithm operates in distinct training and prediction phases: during training, it analyzes historical audio data using the Burg recursion to compute optimal autoregressive coefficients; during prediction, these coefficients forecast missing audio samples. Critical numerical stability enhancements include damping factors, epsilon guards, and enhanced precision arithmetic to ensure reliable real-time operation.

\subsection{Packet Selection and Threading Architecture}

The packet retrieval mechanism implements an intelligent selection algorithm that examines recent arrivals to find optimal packets for playback rather than consuming packets in simple arrival order. The system maintains a circular buffer of recent packet slots with associated timestamps, enabling proper handling of out-of-order delivery, variable latency, and burst loss patterns, as illustrated in Fig.~\ref{fig:packet_timeline}. The core algorithm, detailed in Algorithm~\ref{alg:packet_switching} (Appendix~\ref{sec:algorithm}), employs a tolerance-based packet selection strategy that balances audio continuity with minimal latency requirements.

The selection logic, shown in the flowchart of Figure~\ref{fig:pullpacket_algorithm}, iterates through recently arrived packets from newest to oldest, applying tolerance-based filtering to identify viable candidates. When packets fall outside the tolerance window, the system either selects the best available candidate or triggers predictive audio generation to maintain playback continuity.

\begin{figure}[!t]
\centering
\includegraphics[width=0.9\columnwidth]{switching.png}
\caption{Packet selection algorithm timeline illustrating the temporal decision process for real-time audio streaming. The tolerance window (dashed vertical boundaries) defines the acceptable packet age range based on \texttt{mMsecTolerance}. Packets arriving outside this window are skipped (P1), while candidates within the window (P2, P3, P4, P5) are evaluated. The algorithm selects the optimal packet (P4, shown filled) using the iterative selection logic that examines packets from newest to oldest. Audio callback timing (vertical lines) drives the selection process, ensuring minimal latency while maintaining audio continuity through the Regulator's adaptive buffering mechanism.}
\label{fig:packet_timeline}
\end{figure}

\begin{figure}[!t]
\centering
\includegraphics[width=0.8\columnwidth]{pullPacket.png}
\caption{Flowchart of the packet selection algorithm implemented in \texttt{pullPacket()}. The algorithm iterates through recently arrived packets from newest to oldest, applying tolerance-based filtering to select valid candidates. When a suitable packet is found within the timing tolerance window, normal processing occurs with optional glitch handling for discontinuities. If no valid packets are available, the system enters underrun mode and triggers predictive audio generation to maintain real-time playback continuity.}
\label{fig:pullpacket_algorithm}
\end{figure}


The optional RegulatorWorker provides asynchronous processing through a dedicated high-priority thread, automatically activating when prediction processing exceeds 70\% of the audio callback interval. Communication between threads uses lock-free data structures, specifically the WaitFreeFrameBuffer implementation that provides bounded wait-free operations for both producers and consumers, eliminating priority inversion risks that could compromise real-time audio delivery.
\subsection{Multi-Channel Processing and Adaptive Management}

Each audio channel is managed by a dedicated Channel instance that maintains independent state for prediction operations, essential for proper handling of stereo and multi-channel audio streams where each channel may exhibit distinct spectral characteristics. The Channel class manages an extensive buffer hierarchy including \texttt{realNowPacket}, \texttt{predictedNowPacket}, \texttt{outputNowPacket}, and \texttt{futurePredictedPacket} buffers to support the complete prediction and cross-fading pipeline.

The system implements sophisticated adaptive tolerance control through continuous analysis of timing patterns. Two separate statistical analyzers track push timing for incoming packets and pull timing for audio callbacks, computing rolling statistics and long-term trends. The adaptive algorithm automatically adjusts tolerance thresholds based on observed network jitter patterns, distinguishing between startup transients and steady-state operation while including safeguards against excessive buffer growth.


\subsection{Cross-Fading and Format Adaptation}

To minimize audible artifacts during transitions between predicted and real audio, the system implements sophisticated cross-fading mechanisms using complementary fade curves (\texttt{mFadeUp} and \texttt{mFadeDown}) that blend predicted future packets with newly arrived real data. The cross-fade implementation accounts for potential phase and amplitude differences by using pre-computed future predictions that extend beyond immediate packet boundaries.

The architecture accommodates different audio bit depths (8, 16, 24, 32-bit) through comprehensive conversion systems that maintain precision while adapting to interface requirements. The FPPratio mechanism handles mismatched frame sizes between local audio interfaces and network packet formats by automatically segmenting or aggregating packets, enabling deployment across heterogeneous networks where participants may use different audio configurations while maintaining synchronized playback.

\section{System Evaluation and Testing Framework}

\IEEEPARstart{T}{he} Regulator system evaluation uses a comprehensive testing framework that covers both controlled lab conditions and real-world network scenarios. The approach combines isolated component testing with full system evaluation, using simulated network conditions and actual deployment scenarios to validate the packet loss concealment effectiveness.

\subsection{Testing Architecture and Component Isolation}

The evaluation framework uses a modular approach that tests individual Regulator components in isolation before integration testing. Each major component—Regulator class, BurgAlgorithm class, Channel class, and RegulatorWorker class—undergoes dedicated unit testing to verify functionality and performance.

Component isolation uses controlled test harnesses that simulate specific network conditions and audio patterns. The BurgAlgorithm class gets evaluated independently using pre-recorded audio with artificially introduced gaps, enabling precise measurement of prediction accuracy and computational cost. The Channel class undergoes isolated testing with multi-channel streams to verify per-channel independence and cross-fading behavior.

The framework generates test points derived from unit test scenarios, targeting specific conditions and failure modes. Test scenarios include packet loss rates from 0.1\% to 10\%, different jitter patterns (uniform, bursty, exponential), multiple audio types (speech, music, pink noise, sine waves), and various network topologies (peer-to-peer and server-mediated).

\subsection{Simulated Network Conditions}

Network simulation uses a deterministic packet manipulation system that introduces precise loss patterns, timing variations, and bandwidth constraints. The simulation implements configurable loss models including random uniform loss, Gilbert-Elliott bursty loss, and real-world trace-based patterns from WiFi, cellular, and wired connections.

Jitter simulation covers multiple distribution models: uniform jitter with configurable bounds, Gaussian jitter with variable standard deviation, and exponential patterns modeling network congestion. Performance evaluation spans jitter ranges from 1ms to 100ms, covering typical values from local networks to wide-area Internet connections.

Bandwidth variation testing simulates dynamic conditions by implementing time-varying capacity constraints that force adaptive buffering adjustments. These tests validate the system's ability to maintain audio quality during congestion periods and rapid bandwidth changes typical in mobile and wireless environments.

\subsection{Real Network Testing Scenarios}

Real-world evaluation involves recording incoming packets to the Regulator system along with their sequence numbers and arrival times during actual network sessions. This approach captures authentic network behavior including natural jitter patterns, burst losses, and timing irregularities that occur in production environments.

Packet recording sessions span diverse network infrastructures including university campus networks, residential broadband, cellular data networks, and intercontinental Internet paths. The recorded data includes packet sequence numbers, precise arrival timestamps, and associated network path characteristics such as round-trip times and routing information.

The packet recording framework enables replay-based testing where identical network conditions can be applied to different concealment methods. This approach eliminates network variability between test runs, allowing precise comparison of system performance under authentic but reproducible network conditions.

Geographic distribution testing evaluates performance across network paths with varying round-trip times, from local area networks (sub-millisecond latency) to transcontinental connections (150+ millisecond latency). These tests assess the system's adaptation mechanisms under different baseline latency conditions and validate tolerance management algorithms across diverse network characteristics.

\subsection{Audio Content and Output Generation}

Testing uses diverse audio materials designed to stress different aspects of the prediction algorithms. Test content includes classical music with complex harmonics, speech samples with varying characteristics, synthetic signals with known spectral properties, and specially designed signals that challenge autoregressive prediction.

All test scenarios generate output in uncompressed .wav format at multiple sample rates (44.1kHz, 48kHz, 96kHz) and bit depths (16-bit, 24-bit, 32-bit float) for detailed audio quality analysis. Output files include both processed audio with concealment active and reference files with artificial gaps for direct comparison.

The audio generation framework produces synchronized output from multiple system configurations simultaneously, enabling direct A/B comparison between Regulator and traditional approaches including fixed-size ring buffers, adaptive jitter buffers, and silence insertion methods.

\subsection{Evaluation Metrics and Analysis}

System performance uses both objective metrics and quality measures. Objective metrics include underrun frequency (percentage of audio callbacks experiencing buffer underruns), concealment activation rate (percentage of frames requiring prediction), and latency measurements (end-to-end delay under various conditions).

Audio quality metrics include signal-to-noise ratio (SNR) comparing concealed segments to original content, spectral distortion using log-spectral distance calculations, and temporal continuity assessment through zero-crossing rate analysis. These metrics quantify prediction algorithm fidelity and identify concealment artifacts.

Performance metrics include computational load (CPU utilization during prediction), memory usage patterns (buffer allocation efficiency), and real-time capability (percentage of processing cycles completed within callback deadlines). Thread performance gets evaluated through queue depth monitoring, processing time distributions, and load balancing between audio and worker threads.

Statistical analysis uses paired t-tests for before/after comparisons, ANOVA for multi-condition evaluation, and non-parametric tests when distributions violate normality assumptions. Confidence intervals are computed for all metrics, and effect size calculations quantify practical significance of observed differences.

\subsection{Comparative Evaluation}

The framework enables systematic comparison with existing packet loss concealment approaches through standardized test scenarios and identical network conditions. Baseline comparisons include JackTrip's traditional ring buffers, silence insertion, last packet repetition, and linear interpolation.

Performance comparison uses matched-pair testing where identical audio content and network conditions apply to different concealment methods simultaneously. This eliminates variability from content differences or network changes, enabling precise measurement of relative performance.

The comparative framework generates performance profiles for each tested method, including success rates under various loss conditions, computational overhead comparisons, and audio quality preservation metrics. Results include statistical significance testing and confidence intervals for robust conclusions about relative system performance.

\section{Results and Performance Analysis}

\IEEEPARstart{T}{his} section presents the experimental results obtained from the comprehensive evaluation framework described in Section III. The results are organized to address the key performance aspects of the Regulator system: packet loss concealment effectiveness, adaptive buffering performance, computational efficiency, and comparative analysis against traditional approaches. All results are based on the test scenarios and metrics defined in the evaluation methodology.

\subsection{Packet Loss Concealment Effectiveness}

The effectiveness of the Burg algorithm-based packet loss concealment was evaluated across varying loss rates and network conditions. Figure~\ref{fig:plc_effectiveness} shows the concealment success rates and audio quality metrics as functions of packet loss percentage for different audio content types.

\begin{figure}[!t]
\centering
% Figure showing concealment effectiveness results:
% - X-axis: Packet loss percentage (0.1% to 10%)
% - Y-axis: Quality metrics (SNR, spectral distortion)
% - Multiple lines for different audio types (speech, music, synthetic)
\caption{Packet loss concealment effectiveness showing audio quality metrics versus packet loss percentage for different content types.}
\label{fig:plc_effectiveness}
\end{figure}

[Results on concealment effectiveness across different loss rates will be presented here, including statistical significance testing and confidence intervals]

The Burg algorithm demonstrated particularly strong performance for [specific audio types and conditions to be filled based on actual results]. Cross-fading mechanisms showed [effectiveness metrics to be filled] in maintaining audio continuity during transitions between predicted and real audio segments.

\subsection{Adaptive Buffering Performance}

The adaptive tolerance management system was evaluated under various jitter patterns and network conditions. Results demonstrate the system's ability to automatically adjust buffer parameters based on observed network behavior while maintaining minimal latency.

[Results on adaptive buffering performance, including comparisons between fixed and adaptive approaches, will be presented here]

Underrun reduction compared to fixed-size buffering approaches showed [percentage improvement to be filled] across the tested network conditions. The adaptive algorithm successfully distinguished between startup transients and steady-state operation, with tolerance adjustments occurring [timing and frequency details to be filled].

\subsection{Computational Performance and Real-Time Capability}

Computational load analysis examined CPU utilization, memory usage, and real-time processing capability across different system configurations. Figure~\ref{fig:computational_performance} illustrates the relationship between prediction complexity and processing time for various audio configurations.

\begin{figure}[!t]
\centering
% Figure showing computational performance:
% - Multiple subplots showing CPU usage, memory usage, processing time
% - Comparisons between single-threaded and multi-threaded operation
% - Performance scaling with different audio parameters
\caption{Computational performance analysis showing CPU utilization, memory usage, and processing time distributions for different system configurations and audio parameters.}
\label{fig:computational_performance}
\end{figure}

[Results on computational performance will be presented here, including processing time distributions, memory usage patterns, and real-time capability assessment]

The RegulatorWorker threading implementation showed [performance characteristics to be filled] when prediction processing exceeded the 70\% callback interval threshold. Queue depth monitoring revealed [statistics on queue performance and load balancing to be filled].

\subsection{Multi-Channel Audio Performance}

Per-channel processing evaluation assessed the system's ability to handle stereo and multi-channel audio streams with independent autoregressive modeling. Results demonstrate [performance characteristics for multi-channel processing to be filled].

[Results on multi-channel performance, including channel independence verification and cross-channel interference analysis, will be presented here]

Cross-fading performance in multi-channel scenarios showed [effectiveness metrics to be filled], with phase coherence maintained across [channel configurations tested].

\subsection{Network Condition Adaptation}

The system's adaptation to varying network conditions was evaluated using both simulated and real-world network scenarios. Results show the effectiveness of the tolerance management and packet selection algorithms under different jitter patterns and loss characteristics.

[Results on network adaptation performance will be presented here, including adaptation speed, stability, and effectiveness under various network conditions]

Real-world packet recording and replay testing revealed [insights about authentic network behavior and system adaptation to be filled]. Geographic distribution testing across different network paths showed [latency and adaptation performance characteristics to be filled].

\subsection{Comparative Analysis}

Direct comparison with existing JackTrip buffering strategies and traditional packet loss concealment methods was conducted using matched-pair testing under identical network conditions. Table~\ref{tab:comparative_results} summarizes the key performance metrics across different approaches.

\begin{table}[!t]
\renewcommand{\arraystretch}{1.3}
\caption{Comparative Performance Analysis}
\label{tab:comparative_results}
\centering
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Method} & \textbf{Underrun Rate} & \textbf{Audio Quality} & \textbf{CPU Usage} & \textbf{Latency} \\
\hline
Fixed Ring Buffer & [%] & [SNR dB] & [%] & [ms] \\
\hline
Adaptive Jitter Buffer & [%] & [SNR dB] & [%] & [ms] \\
\hline
Silence Insertion & [%] & [SNR dB] & [%] & [ms] \\
\hline
Linear Interpolation & [%] & [SNR dB] & [%] & [ms] \\
\hline
Regulator System & [%] & [SNR dB] & [%] & [ms] \\
\hline
\end{tabular}
\end{table}

[Detailed comparative analysis results will be presented here, including statistical significance testing and effect size calculations]

The Regulator system demonstrated [comparative performance characteristics to be filled] relative to traditional approaches, with particular advantages in [specific scenarios or conditions to be filled].

\subsection{Statistical Analysis and Significance Testing}

All reported results include statistical significance testing with appropriate confidence intervals. [Statistical analysis results will be presented here, including p-values, confidence intervals, and effect sizes for key comparisons]

Performance variation analysis across different test conditions revealed [insights about system robustness and consistency to be filled]. Long-term stability testing showed [characteristics of system behavior over extended operation periods to be filled].

\section{Discussion}

\IEEEPARstart{T}{he} results presented in Section IV demonstrate the effectiveness of the Regulator system across various network conditions and audio content types. This section analyzes the implications of these findings, discusses the limitations of the current approach, and examines the broader impact on networked audio applications.

\subsection{Performance Implications}

[Analysis of the performance results and their implications for real-world deployment will be presented here]

\subsection{System Limitations and Trade-offs}

[Discussion of system limitations, computational trade-offs, and scenarios where the approach may be less effective will be presented here]

\subsection{Deployment Considerations}

[Analysis of practical deployment considerations, scalability issues, and integration challenges will be presented here]

\subsection{Future Enhancements}

[Discussion of potential improvements and future research directions will be presented here]

\section{Conclusion}

\IEEEPARstart{T}{he} Regulator system presents a novel approach to packet loss concealment for interactive network audio applications, addressing the critical challenge of maintaining audio quality while preserving low-latency requirements essential for real-time collaboration.

[Summary of key contributions and findings will be presented here]

[Discussion of broader impact on network audio systems and future research directions will be presented here]

\appendix


\section{Packet Selection Algorithm}
\label{sec:algorithm}

The core packet selection mechanism is implemented through the algorithm presented below, which forms the foundation of the Regulator's real-time packet processing capabilities.

\begin{algorithm}[!t]
\caption{Packet Selection and Switching Logic}
\label{alg:packet_switching}
\begin{algorithmic}[1]
\REQUIRE Incoming packets, current time $t_{now}$, tolerance threshold $\tau$
\ENSURE Selected packet or prediction trigger
\STATE $new\_pkts \leftarrow$ count packets since last callback
\STATE $next \leftarrow mLastSeqNumOut + 1$
\STATE $skipped \leftarrow 0$
\FOR{$i = new\_pkts - 1$ \textbf{down to} $0$}
    \STATE $candidate \leftarrow packet[next + i]$
    \STATE $age \leftarrow t_{now} - arrival\_time[candidate]$
    \IF{$age \leq \tau$}
        \STATE $mLastSeqNumOut \leftarrow candidate$
        \STATE \textbf{goto} PACKET\_OK
    \ENDIF
    \STATE $skipped \leftarrow skipped + 1$
\ENDFOR
\STATE \textbf{goto} UNDERRUN
\STATE
\STATE \textbf{PACKET\_OK:}
\IF{$skipped > 0$ \textbf{and} \textbf{not} $mLastWasGlitch$}
    \STATE $processPacket(GLITCH = true)$ \COMMENT{trigger prediction}
\ELSE
    \STATE $processPacket(GLITCH = false)$ \COMMENT{use real data}
\ENDIF
\STATE \textbf{return}
\STATE
\STATE \textbf{UNDERRUN:}
\STATE $processPacket(GLITCH = true)$ \COMMENT{generate prediction}
\end{algorithmic}
\end{algorithm}

\section{Unit Test Specifications}

This appendix details the comprehensive unit test suite designed to validate individual Regulator system components. Each test is designed to verify specific functionality and performance characteristics in isolation before integration testing.

\subsection{Regulator Class Unit Tests}

\subsubsection{Initialization and Configuration Tests}
\begin{itemize}
\item \texttt{testRegulatorInitialization()}: Verifies proper initialization of member variables, buffer allocation, and default parameter settings
\item \texttt{testFPPConfigurationDetection()}: Tests automatic detection and configuration of peer frame-per-packet settings
\item \texttt{testLocalFPPConfiguration()}: Validates local audio interface FPP configuration and ratio calculations
\item \texttt{testPacketStorageInitialization()}: Verifies proper allocation and indexing of packet storage arrays
\end{itemize}

\subsubsection{Packet Management Tests}
\begin{itemize}
\item \texttt{testPushPacketBasic()}: Tests basic packet reception, timestamping, and storage functionality
\item \texttt{testPushPacketSequenceNumbering()}: Verifies correct handling of packet sequence numbers and indexing
\item \texttt{testPushPacketTimestamping()}: Tests accurate timestamping of incoming packets with local clock
\item \texttt{testPushPacketOverflow()}: Validates behavior when packet storage arrays reach capacity
\item \texttt{testPullPacketBasic()}: Tests basic packet retrieval and output generation
\item \texttt{testPullPacketSequencing()}: Verifies correct sequence number increment and tracking
\item \texttt{testPullPacketTiming()}: Tests timing-based packet selection within tolerance windows
\end{itemize}

\subsubsection{Tolerance and Adaptation Tests}
\begin{itemize}
\item \texttt{testToleranceInitialization()}: Verifies initial tolerance parameter setup and default values
\item \texttt{testToleranceAdaptation()}: Tests automatic tolerance adjustment based on network statistics
\item \texttt{testHeadroomManagement()}: Validates adaptive headroom calculation and bounds checking
\item \texttt{testGlitchThresholdHandling()}: Tests response to glitch rate threshold violations
\item \texttt{testStatisticsCollection()}: Verifies proper collection and analysis of timing statistics
\end{itemize}

\subsubsection{Underrun and Overrun Handling Tests}
\begin{itemize}
\item \texttt{testUnderrunDetection()}: Tests detection of buffer underrun conditions
\item \texttt{testOverrunDetection()}: Tests detection and handling of packet arrival overruns
\item \texttt{testUnderrunRecovery()}: Validates recovery mechanisms after underrun events
\item \texttt{testLongUnderrunHandling()}: Tests behavior during extended stream stalls (>30ms)
\item \texttt{testMutePacketGeneration()}: Verifies generation of silence during egregious underruns
\end{itemize}

\subsection{BurgAlgorithm Class Unit Tests}

\subsubsection{Algorithm Core Tests}
\begin{itemize}
\item \texttt{testBurgInitialization()}: Verifies proper initialization of algorithm parameters and buffers
\item \texttt{testForwardBackwardBufferInit()}: Tests initialization of forward and backward prediction buffers
\item \texttt{testCoefficientArrayInit()}: Validates autoregressive coefficient array initialization
\item \texttt{testDampingFactorApplication()}: Tests application of damping factors for numerical stability
\item \texttt{testEpsilonGuardProtection()}: Verifies epsilon guard protection against division by zero
\end{itemize}

\subsubsection{Training Phase Tests}
\begin{itemize}
\item \texttt{testBurgRecursionBasic()}: Tests basic Burg recursion algorithm implementation
\item \texttt{testReflectionCoefficientComputation()}: Validates reflection coefficient calculation accuracy
\item \texttt{testCoefficientUpdate()}: Tests autoregressive coefficient update during recursion
\item \texttt{testConvergenceDetection()}: Verifies algorithm convergence detection and handling
\item \texttt{testNumericalStability()}: Tests numerical stability under various signal conditions
\end{itemize}

\subsubsection{Prediction Phase Tests}
\begin{itemize}
\item \texttt{testPredictionBasic()}: Tests basic audio sample prediction using computed coefficients
\item \texttt{testPredictionHorizon()}: Validates prediction beyond immediate missing packets
\item \texttt{testPredictionAccuracy()}: Tests prediction accuracy with known signal patterns
\item \texttt{testFuturePredictionGeneration()}: Verifies generation of future samples for cross-fading
\item \texttt{testPredictionBounds()}: Tests prediction output bounds and clipping behavior
\end{itemize}

\subsection{Channel Class Unit Tests}

\subsubsection{Buffer Management Tests}
\begin{itemize}
\item \texttt{testChannelInitialization()}: Verifies proper initialization of all channel buffers
\item \texttt{testRealNowPacketHandling()}: Tests storage and retrieval of real audio packets
\item \texttt{testPredictedNowPacketHandling()}: Validates predicted audio packet management
\item \texttt{testOutputNowPacketGeneration()}: Tests final output packet generation and formatting
\item \texttt{testFuturePredictedPacketManagement()}: Verifies future prediction buffer operations
\item \texttt{testPacketRingBufferOperations()}: Tests circular ring buffer implementation and wraparound
\end{itemize}

\subsubsection{Cross-Fading Tests}
\begin{itemize}
\item \texttt{testCrossFadeInitialization()}: Verifies initialization of cross-fade envelope parameters
\item \texttt{testFadeUpEnvelopeGeneration()}: Tests generation of fade-up envelope curves
\item \texttt{testFadeDownEnvelopeGeneration()}: Tests generation of fade-down envelope curves
\item \texttt{testComplementaryFadeApplication()}: Validates application of complementary fade curves
\item \texttt{testCrossFadeTransition()}: Tests complete cross-fade transition from predicted to real audio
\item \texttt{testPhaseCoherencePreservation()}: Verifies maintenance of phase relationships during fading
\end{itemize}

\subsection{RegulatorWorker Class Unit Tests}

\subsubsection{Threading Tests}
\begin{itemize}
\item \texttt{testWorkerInitialization()}: Verifies proper worker thread initialization and priority setting
\item \texttt{testWorkerActivation()}: Tests automatic worker activation when processing thresholds are exceeded
\item \texttt{testWorkerDeactivation()}: Validates worker thread shutdown and cleanup procedures
\item \texttt{testRealTimePriorityAssignment()}: Tests assignment of real-time scheduling priority
\item \texttt{testGracefulDegradation()}: Verifies graceful degradation when worker queue becomes full
\end{itemize}

\subsubsection{Queue Management Tests}
\begin{itemize}
\item \texttt{testQueueInitialization()}: Tests initialization of WaitFreeFrameBuffer queue structure
\item \texttt{testQueueProducerOperations()}: Validates lock-free producer operations and data insertion
\item \texttt{testQueueConsumerOperations()}: Tests lock-free consumer operations and data retrieval
\item \texttt{testQueueCapacityManagement()}: Verifies queue capacity limits and overflow handling
\item \texttt{testAdaptiveQueueSizing()}: Tests automatic queue size adjustment based on underrun patterns
\item \texttt{testQueuePerformanceMonitoring()}: Validates queue depth monitoring and performance metrics
\end{itemize}

\section*{ACKNOWLEDGMENT}

The authors thank the contributors to the JackTrip project and the Stanford University SoundWIRE research group for their support and collaboration in developing and testing the Regulator system.

\begin{thebibliography}{00}

\bibitem{bib1} J. P. Burg, ``Maximum entropy spectral analysis,'' Ph.D. dissertation, Dept. Geophys., Stanford Univ., Stanford, CA, USA, 1975.

\bibitem{bib2} J. D. Markel and A. H. Gray, \emph{Linear Prediction of Speech}. Berlin, Germany: Springer-Verlag, 1976.

\bibitem{bib3} C. Perkins, \emph{RTP: Audio and Video for the Internet}. Boston, MA, USA: Addison-Wesley Professional, 2003.

\bibitem{bib4} C. Rottondi, C. Chafe, C. Allocchio, and A. Sarti, ``An overview on networked music performance technologies,'' \emph{IEEE Access}, vol. 4, pp. 8823--8843, 2016, doi: 10.1109/ACCESS.2016.2628440.

\bibitem{bib5} A. Carôt and C. Werner, ``Networked music performance - state of the art,'' in \emph{Proc. Audio Eng. Soc. Conf.}, 2009, pp. 1--10.

\end{thebibliography}


\end{document}

